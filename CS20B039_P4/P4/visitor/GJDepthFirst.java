//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

//import jdk.nashorn.internal.codegen.SpillObjectCreator;



/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //


   static class StackEnt 
   {
      String temporaryno;
      int spillNo;

      public int getSpillNo()
      {
         return spillNo;
      }

      public String getTemporaryNo()
      {
         return temporaryno;
      }

      public void setSpillNo(int x)
      {
         this.spillNo = x;
      }

      public void setTemporaryNo(String x)
      {
         this.temporaryno = x;
      }
   }


   static class Register 
   {
      boolean active;
      int number;
      String name;

      Register()
      {
         active = false;
      }

      public boolean getActive()
      {
         return active;
      }

      public void setActive(boolean x)
      {
         if(x) this.active = true;
         else this.active = false;
      }

      public int getNumber()
      {
         return number;
      }

      public String getName()
      {
         return name;
      }

      public void setName(String n)
      {
         this.name = n;
      }

      public void setNumber(int x)
      {
         this.number = x;
      }
   }


   static class LiveLabel
   {
      int procedure;
      String name;
      int startline;
      int endline;

      LiveLabel()
      {
         startline = Integer.MAX_VALUE;
         endline = -1;
      }

      public String getName()
      {
         return name;
      }

      public void setName(String n)
      {
         this.name = n;
      }

      public void setStartLine(int x)
      {
         this.startline = x;
      }

      public int getStartLine()
      {
         return startline;
      }

      public void setProcedure(int x)
      {
         this.procedure = x;
      }

      public int getProcedure()
      {
         return procedure;
      }

      public void setEndLine(int x)
      {
         this.endline = x;
      }

      public int getEndLine()
      {
         return endline;
      }

      

   }
	
   static class LiveVariable
   {
      String temporaryno;
      int procedure;
      int startline;
      int endline;
      boolean argument;
      String registerAllotname;
      int registerAllot;

      LiveVariable()
      {
         startline=Integer.MAX_VALUE;
         endline=-1;
         argument = false;
         registerAllotname = null;
         registerAllot = -1;
      }

      public void setArgument(boolean x)
      {
         if(x) this.argument = true;
         else this.argument = false;
      }

      public int getRegisterAllot()
      {
         return registerAllot;
      }

      public void setStartLine(int x)
      {
         this.startline = x;
      }

      public int getStartLine()
      {
         return startline;
      }

      public void setRegisterAllot(int x)
      {
         this.registerAllot = x;
      }

      public void setEndLine(int x)
      {
         this.endline = x;
      }

      public int getEndLine()
      {
         return endline;
      }

      public void setProcedure(int x)
      {
         this.procedure = x;
      }

      public int getProcedure()
      {
         return procedure;
      }

      public String getTemporaryNo()
      {
         return temporaryno;
      }

      public void setTemporaryNo(String x)
      {
         this.temporaryno=x;
      }

   }


   static class LocalStack
   {
      Vector<StackEnt> stackDeets;

      LocalStack()
      {
         stackDeets = new Vector<StackEnt>();
      }

      public Vector<StackEnt> getStackDeets()
      {
         return stackDeets;
      }

      public void setStackdeets(Vector<StackEnt> stackDeets)
      {
         this.stackDeets = stackDeets;
      }

      public void clear()
      {
         stackDeets.clear();
      }

      public int locateOnStack(String t)
      {
         int s = stackDeets.size();
         int i=0;
         int ret=-1;

         while(i<s)
         {
            if(t.equals(stackDeets.get(i).temporaryno)) 
            {
               ret = stackDeets.get(i).spillNo;
               return ret;
            }
            i++;
         }
         return ret;
      }


      public void beginProc(int args)
      {
         if(args<=4)
         {
            int i=0;
            while(i<8)
            {
               System.out.println("ASTORE SPILLEDARG "+i+" s"+i);
               i++;
            }
         }
         else if(args>4)
         {
            int i=args-4;
            while(i<args+4)
            {
               System.out.println("ASTORE SPILLEDARG "+i+" s"+(i-args+4));
               i++;
            }
         }
      }


      public void endProc(int args)
      {
         if(args<=4)
         {
            int i=0;
            while(i<8)
            {
               System.out.println("ALOAD s"+i+" SPILLEDARG "+i);
               i++;
            }
         }
         else if(args>4)
         {
            int i=args-4;
            while(i<args+4)
            {
               System.out.println("ALOAD s"+(i-args+4)+" SPILLEDARG "+i);
               i++;
            }
         }
      }


      public void beginCall(int s)
      {
         int i=0;
         while(i<10)
         {
            System.out.println("ASTORE SPILLEDARG "+(s+i)+" t"+i);
            i++;
         }
      }

      public void endCall(int s)
      {
         int i=0;
         while(i<10)
         {
            System.out.println("ALOAD t"+i+" SPILLEDARG "+(s+i));
            i++;
         }
      }
   }



   static class ProcedureInfo
   {
      String procedure;
      String arguments;
      Vector<Integer> calls;
      int startline;
      int endline;
      int stackspacesall;
      int stackspacesproc;
      int maxcall;

      ProcedureInfo()
      {
         calls = new Vector<Integer>();
         maxcall=0;
      }

      public void setCalls(Vector<Integer> calls)
      {
         this.calls = calls;
      }

      public Vector<Integer> getCalls()
      {
         return calls;
      }

      public void setProcedure(String x)
      {
         this.procedure = x;
      }

      public String getProcedure()
      {
         return procedure;
      }

      public void setArguments(String x)
      {
         this.arguments = x;
      }

      public String getArguments()
      {
         return arguments;
      }

      public void setStartLine(int x)
      {
         this.startline = x;
      }

      public int getStartLine()
      {
         return startline;
      }

      public void setEndLine(int x)
      {
         this.endline = x;
      }

      public int getEndLine()
      {
         return endline;
      }

      public void setStackspacesall(int x)
      {
         this.stackspacesall = x;
      }

      public int getStackspacesall()
      {
         return stackspacesall;
      }

      public void setStackspacesproc(int x)
      {
         this.stackspacesproc = x;
      }

      public int getStackspacesproc()
      {
         return stackspacesproc;
      }
   }


   public static class ScanTable
   {
      Vector<ProcedureInfo> Procedures;
      Vector<LiveLabel> Labels;
      int totalLines;
      Vector<LiveVariable> Temporaries;
      int remover;

      ScanTable()
      {
         Procedures = new Vector<ProcedureInfo>();
         Labels = new Vector<LiveLabel>();
         totalLines=-1;
         Temporaries = new Vector<LiveVariable>();
         remover=0;
      }

      public int LabelSearch(String n)
      {
         int i=0;
         int s = Labels.size();
         int ret = -1;
         while(i<s)
         {
            if(n.compareTo(Labels.get(i).name)==0)
               return i;
            i++;
         }
         return ret;
      }

      public int TempSearch(String tempno, int curproc)
      {
         int i=0;
         int s=Temporaries.size();

         int ret = -1;

         while(i<s)
         {
            if(Temporaries.get(i).procedure==curproc && tempno.compareTo(Temporaries.get(i).temporaryno)==0)
               return i;
            i++;
         }
         return ret;
      }

      public void LabelStart(String name, int startl, int curproc)
      {
         int x = this.LabelSearch(name);
         if(x!=-1)
         {
            Labels.get(x).startline = Math.min(startl, Labels.get(x).startline);
         }
         else if(x==-1)
         {
            LiveLabel l = new LiveLabel();
            String a = name;
            l.setName(a);
            int y = startl;
            l.setStartLine(y);
            l.procedure=curproc;
            Labels.add(l);
         }
      }

      public void LabelEnd(String name, int endl, int curproc)
      {
         int x = this.LabelSearch(name);
         if(x!=-1)
         {
            Labels.get(x).endline = Math.max(endl, Labels.get(x).endline);
         }
         else if(x==-1)
         {
            LiveLabel l = new LiveLabel();
            l.setName(name);
            int y = endl;
            l.setEndLine(y);
            int b = curproc;
            l.procedure=b;                                                         
            Labels.add(l);
         }
      }

      public void TempStart(String tno, int startl, int curproc)
      {
         int x = this.TempSearch(tno,curproc);

         if(x!=-1)
         {
            Temporaries.get(x).startline = Math.min(startl,Temporaries.get(x).startline);
         }
         else if(x==-1)
         {
            LiveVariable v = new LiveVariable();
            v.setTemporaryNo(tno);
            int c = startl;
            v.setStartLine(c);
            int d = curproc;
            v.setProcedure(d);
            Temporaries.add(v);
         }
      }

      public void TempEnd(String tno, int endl, int curproc)
      {
         int x = this.TempSearch(tno,curproc);

         if(x!=-1)
         {
            Temporaries.get(x).endline = Math.max(endl,Temporaries.get(x).endline);
         }
         else if(x==-1)
         {
            LiveVariable v = new LiveVariable();
            v.setTemporaryNo(tno);
            int y = endl;
            v.setEndLine(y);
            int z = curproc;
            v.setProcedure(z);
            Temporaries.add(v);
         }
      }


      public void Initialize()
      {
         this.BasicSetup();
         this.RegisterSetup();
         int b = 0;
         if(b==0) this.OtherSetup();
      }

      /*public void PrintTable()
      {
         for(int i=0;i<Procedures.size();i++) System.out.println(Procedures.get(i).procedure+" "+Procedures.get(i).arguments+" "+Procedures.get(i).startline+" "+Procedures.get(i).endline+" "+Procedures.get(i).maxcall);
         for(int i=0;i<Labels.size();i++) System.out.println(Labels.get(i).name+" "+Labels.get(i).procedure+" "+Labels.get(i).startline+" "+Labels.get(i).endline);
         for(int i=0;i<Temporaries.size();i++) System.out.println(Temporaries.get(i).temporaryno+" "+Temporaries.get(i).procedure+" "+Temporaries.get(i).startline+" "+Temporaries.get(i).endline+" "+Temporaries.get(i).registerAllotname+" "+Temporaries.get(i).registerAllot);
      }*/

      public void BasicSetup()
      {
         int psize = Procedures.size();
         int tsize = Temporaries.size();
         int lsize = Labels.size();

         Vector<Integer> Faulty = new Vector<Integer>();

         int j=0;
         int i=0;
         while(j<psize)
         {
            for(i=0;i<Procedures.get(j).calls.size();i++)
            {
               Procedures.get(j).maxcall=Math.max(Procedures.get(j).maxcall,Procedures.get(j).calls.get(i));
            }
            j++;
         }

         i=0;
         while(i<lsize)
         {
            if(Labels.get(i).startline<=Labels.get(i).endline)
            {
               for(j=0;j<tsize;j++)
               {
                  int x = Temporaries.get(j).endline;
                  int y = Labels.get(i).endline;
                  if(x<y && x>Labels.get(i).startline)
                     Temporaries.get(j).endline = Labels.get(i).endline;
                  
               }
            }
            i++;
         }


         i=0;
         while(i<psize)
         {
            for(j=0;j<tsize;j++)
            {
               int a = Temporaries.get(j).procedure;
               if(a==i)
               {
                  if(Integer.parseInt(Temporaries.get(j).temporaryno.substring(1)) <= Integer.parseInt(Procedures.get(i).arguments))
                  {
                     int p = Procedures.get(i).startline;
                     Temporaries.get(j).startline = p;
                  }
               }
            }
            i++;
         }

         for(i=0;i<tsize;i++)
         {
            int x = Temporaries.get(i).endline;
            if(x==-1) Faulty.add(i);
            else {
               String ok = "ok";
            }
         }

         i=Faulty.size()-1;
         while(i>=0)
         {
            int ind = Faulty.get(i);
            Temporaries.remove(ind);
            i--;
         }

      }


      

      public int SpillCount(Vector<Integer> activeTemps, Vector<Register> usedRegs)
      {
         int notstacked = activeTemps.size();
         boolean spill = true;
         int spilled=0;

         while(activeTemps.size()>usedRegs.size())
         {
            int max = MaxEndPoint(activeTemps);
            int set = -10;
            Temporaries.get(max).setRegisterAllot(set);
            if(spill) Temporaries.get(max).registerAllotname = "stack";
            else
            {
               spill=true;
            }
            activeTemps.remove(remover);
            if(spill==true) spilled++;
         }

         int atsize = activeTemps.size();
         int a=0;
         boolean spill2 = false;
         while(a<atsize)
         {
            if(Temporaries.get(activeTemps.get(a)).registerAllot >= 0) 
               usedRegs.get(Temporaries.get(activeTemps.get(a)).registerAllot).active=true;
            a++;
         }

         for(a=0;a<atsize;a++)
         {
            int temp_reg = Temporaries.get(activeTemps.get(a)).registerAllot;

            if(temp_reg==-1 && !spill2)
            {
               int usize = usedRegs.size();
               for(int r=0;r<usize;r++)
               {
                  if(!usedRegs.get(r).active)
                  {
                     usedRegs.get(r).active=true;
                     Temporaries.get(activeTemps.get(a)).registerAllot = usedRegs.get(r).getNumber();
                     if(!spill2) Temporaries.get(activeTemps.get(a)).registerAllotname = usedRegs.get(r).getName();
                     else 
                        spill2 = false;
                     break;
                  }
               }
            }
         }

         if(spilled==0) return 0;
         else return spilled;
      }


      public void RegisterSetup()
      {
         Vector<Register> usedRegs = new Vector<Register>();

         for(int i=0;i<18;i++)
         {
            Register Reg = new Register();
            Reg.number=i;
            String regname = new String();
            if(i<10) 
               regname = ("t"+Reg.number);
            else 
               regname = ("s"+(Reg.number-10));
            Reg.setName(regname);
            usedRegs.add(Reg);
         }

         int psize = Procedures.size();
         int tsize = Temporaries.size();

         for(int p=0;p<psize;p++)
         {
            int stackspaces;
            int temp61;
            stackspaces=temp61=0;
            Vector<Integer> activeTemps = new Vector<Integer>();

            for(int t=0;t<tsize;t++)
            {
               if(Temporaries.get(t).procedure==p)
               {
                  if(Temporaries.get(t).temporaryno.equals("T61"))
                  {  
                     int a = t; 
                     temp61 = a;
                  }
               }
            }

            for(int l=Procedures.get(p).startline; l<=Procedures.get(p).endline ; l++)
            {
               for(int temp=0; temp<tsize ; temp++)
               {
                  int p1 = Temporaries.get(temp).procedure;
                  if(p1 == p)
                  {
                     if(Temporaries.get(temp).startline<=l && Temporaries.get(temp).endline >= l)
                     {
                        boolean flag = true;
                        if(flag) activeTemps.add(temp);
                     }
                  }
               }

               int moreSpill = SpillCount(activeTemps, usedRegs);
               stackspaces+= moreSpill;
               int lim = usedRegs.size();
               for(int q=0;q<lim;q++)
                  usedRegs.get(q).active=false;

               activeTemps.clear();
            }

            Procedures.get(p).stackspacesproc = stackspaces;

         }
      }


      public int MaxEndPoint(Vector<Integer> activeTemps)
      {
         int curendline;
         int maxtemp;
         curendline = maxtemp = -1;
         boolean flag;
         int atsize = activeTemps.size();
         int a =0;

         flag=true;
         while(a<atsize)
         {
            if(Temporaries.get(activeTemps.get(a)).endline > curendline && flag)
            {
               curendline = Temporaries.get(activeTemps.get(a)).endline;
               maxtemp = activeTemps.get(a);
               if(flag!=true) 
                  flag = true;
               remover = a;
            }
            a++;
         }
         return maxtemp;
      }


      public String FindTemporary(int curproc, String t)
      {
         int tsize = Temporaries.size();
         int i=0;
         String ret=null;
         while(i<tsize)
         {
            String a = Temporaries.get(i).temporaryno;
            int b = Temporaries.get(i).procedure;
            if(a.equals(t) && b==curproc) 
            {
               String ret2 = Temporaries.get(i).registerAllotname;
               return ret2;
            }
            i++;
         }
         return ret;
      }

      public void OtherSetup()
      {
         int psize = Procedures.size();
         int i=0;
         while(i<psize)
         {                                                                              
            Procedures.get(i).stackspacesall = 8+ Math.max(Integer.parseInt(Procedures.get(i).arguments)-4,0);
            boolean check = true;
            if(Procedures.get(i).calls.size()>0 && check) 
               Procedures.get(i).stackspacesall+=10;
            Procedures.get(i).stackspacesall+=Procedures.get(i).stackspacesproc;
            i++;
         }
      }

   }




	
   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return (R)n.tokenImage; }


   public ScanTable Map = new ScanTable();
   public LocalStack SpillMop2 = new LocalStack();
   public int passnumber = 0;
   int curproc;
   boolean useful2 = true;
   boolean special2 = false;
   int lnum = 0;
   int num_args=0;
   boolean arguments=false;   
   int curproc2 = -1;
   int stackcur2=-1;
   boolean temporary = false;
   boolean label_start = true;
   boolean v0avail2 = true;
   boolean arguments2 = false;
   boolean labelstart2 = true;
   boolean v1avail2 = true; 
   int num_arguments2 = 0;
   boolean temporary2 = false;
   

   public String loadRegisterNo(String tno, boolean flag)
   {
      String reg = Map.FindTemporary(curproc2, tno);
      int stackloc = -1;

      if(reg.compareTo("stack")==0)
      {
         stackloc = SpillMop2.locateOnStack(tno);
         if(v0avail2)
         {
            System.out.println("ALOAD v0 SPILLEDARG "+stackloc);
            if(flag) v0avail2=false;
            else 
            {
               v0avail2 = !flag;
            }
            if(special2) v0avail2 = true;
            return "v0";
         }
         else if(v1avail2)
         {
            System.out.println("ALOAD v1 SPILLEDARG "+stackloc);
            if(flag) v1avail2=false;
            else
            {
               v1avail2 = !flag;
            }
            if(special2) v1avail2 = true;
            return "v1";
         }
         else return null;
      }
      else 
      {
         if(reg==null) return null;
         else return reg;
      }
   }

   public String giveRegNo(String tno)
   {
      String reg = Map.FindTemporary(curproc2, tno);
      return reg;                                                          
   }

   public void Analyse(int cp)
   {
      String x = Map.Procedures.get(cp).arguments;
      int lim = Integer.parseInt(x);
      for(int i=0;i<lim;i++)
      {
         String temp = "T"+i;
         String reg = giveRegNo(temp);

         if(reg==null) continue;
         
         if(i<4)
         {
            String exp = "a"+i;
            if(reg.equals("stack"))
            {
               String sp = " ";
               System.out.println("MOVE v0"+sp+exp);
               int stacklocation=0;
               stacklocation = SpillMop2.locateOnStack(temp);
               if(stacklocation!=-1)
               {
                  String printstr = "ASTORE SPILLEDARG "+stacklocation+" v0";
                  System.out.println(printstr);
               }
               else
               {
                  System.out.println("ASTORE SPILLEDARG "+stackcur2+" v0");
                  StackEnt newt = new StackEnt();
                  int mid = stackcur2;
                  newt.setSpillNo(mid);
                  newt.setTemporaryNo(temp);
                  SpillMop2.stackDeets.add(newt);
                  stackcur2++;
               }
            }
            else if(reg.compareTo("stack")!=0)
            {
               System.out.println("MOVE "+reg+" "+exp);
            }
         }
         else 
         {
            String exp = "SPILLEDARG "+(i-4);
            System.out.println("ALOAD v0 "+"SPILLEDARG "+(i-4));

            if(reg.equals("stack"))
            {
               int stacklocation = SpillMop2.locateOnStack(temp);
               if(stacklocation!=-1)
               {
                  String sp = " ";
                  String res = ("ASTORE SPILLEDARG "+stacklocation+sp+"v0");
                  System.out.println(res);
               }
               else
               {
                  System.out.println("ASTORE SPILLEDARG "+ stackcur2+" v0");
                  StackEnt newt = new StackEnt();
                  int mid = stackcur2;
                  newt.setSpillNo(mid);
                  newt.setTemporaryNo(temp);
                  SpillMop2.stackDeets.add(newt);
                  stackcur2++;
               }
            }
            else 
            {
               System.out.println("MOVE "+reg+" v0");
            }
         }
         
      }
   }


   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         ProcedureInfo p = new ProcedureInfo();
         boolean marker = true;
         label_start= !marker;
         String nm = (String) n.f0.accept(this, argu);   
         label_start= marker;
         p.setProcedure(nm); 
         n.f1.accept(this, argu);  
         String as = (String) n.f2.accept(this, argu);
         p.setArguments(as);
         p.setStartLine(lnum);
         lnum++;
         curproc++;
         Map.Procedures.add(p);          
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         int set = lnum;
         Map.Procedures.get(curproc).setEndLine(set);
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         labelstart2=false;
         n.f0.accept(this, argu);
         labelstart2=true;
         curproc2++;
         System.out.print(Map.Procedures.get(curproc2).procedure+"["+Map.Procedures.get(curproc2).arguments+"][");
         System.out.print(Map.Procedures.get(curproc2).stackspacesall+"]["+Map.Procedures.get(curproc2).maxcall+"]"); 
         System.out.println();    
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);    
         n.f3.accept(this, argu);
         int ph = 8+Math.max(0,Integer.parseInt(Map.Procedures.get(curproc2).arguments)-4);
         stackcur2 = ph;
         int arg = Integer.parseInt(Map.Procedures.get(curproc2).arguments);
         SpillMop2.beginProc(arg);
         n.f4.accept(this, argu);
         arg = Integer.parseInt(Map.Procedures.get(curproc2).arguments);
         SpillMop2.endProc(arg);
         String toprint = "END";
         System.out.println(toprint);
         SpillMop2.clear();
         stackcur2=0;
         return _ret;
      }
      else
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);    
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         return _ret;
      }
   }
   

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         ProcedureInfo p = new ProcedureInfo();
         String proc = "Main";
         p.setProcedure(proc);
         p.startline = lnum;
         String ar = "0";
         p.setArguments(ar);
         lnum++;
         int lim = curproc;
         if(curproc>0) for(int j=0;j<lim;j++)curproc--;
         else curproc=0;
         Map.Procedures.add(p);
         String te = (String) n.f1.accept(this, argu);
         n.f2.accept(this, argu); 
         Map.Procedures.get(curproc).setEndLine(lnum);
         lnum++;   
         n.f3.accept(this, argu);
         n.f4.accept(this, argu); 
         int tl = lnum;
         Map.totalLines = tl;     
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         curproc2=0;
         n.f0.accept(this, argu);
         ProcedureInfo p = new ProcedureInfo();
         p = Map.Procedures.get(curproc2);
         System.out.println("MAIN["+p.arguments+"]["+p.stackspacesall+"]["+p.maxcall+"]");
         String x = Map.Procedures.get(curproc2).arguments;
         int comp = Integer.parseInt(x)-4;
         stackcur2 = 8+Math.max(0, comp);
         String tp = "END";
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);  
         System.out.println(tp);
         boolean f = false;
         if(!f) SpillMop2.clear();
         int lim = stackcur2;
         if(stackcur2>0) for(int j=0;j<lim;j++)stackcur2--; 
         else stackcur2=0;   
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);      
         return _ret;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);    
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
        
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         return _ret;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
         
      if(passnumber==1)
      {
         R _ret=null;  
         n.f0.accept(this, argu);      
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;  
         n.f0.accept(this, argu);
         boolean f2 = true; 
         v0avail2=f2;
         v1avail2=f2;     
         return _ret;
      }
      else 
      {
         R _ret=null;  
         n.f0.accept(this, argu);      
         return _ret;
      }
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
         
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         lnum++;
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         String pr = "NOOP";
         System.out.println(pr);
         return _ret;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         lnum++;
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         String pr = "ERROR";
         System.out.println(pr);
         return _ret;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         Map.TempEnd((String)n.f1.accept(this, argu),lnum,curproc);
         boolean flag = true;
         label_start= !flag;
         String nm = (String) n.f2.accept(this, argu);
         label_start= flag;
         Map.LabelEnd(nm,lnum,curproc);
         lnum++;
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         String rname = loadRegisterNo((String) n.f1.accept(this, argu), true);
         labelstart2=false;
         String lbl = (String) n.f2.accept(this, argu);
         labelstart2=true;
         String pr = ("CJUMP "+rname+" "+lbl);
         System.out.println(pr);
         return _ret;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         boolean flag = true;
         label_start=!flag;
         String nm = (String) n.f1.accept(this, argu);
         boolean ok = true;
         if(ok) label_start=ok;
         Map.LabelEnd(nm,lnum,curproc);
         lnum++;
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         boolean flagb = false;
         labelstart2=flagb;
         String lbl = (String) n.f1.accept(this, argu);
         labelstart2= !flagb;
         String pr = ("JUMP "+lbl);
         System.out.println(pr);
         return _ret;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         Map.TempEnd((String)n.f1.accept(this, argu), lnum, curproc);
         n.f2.accept(this, argu);
         Map.TempEnd((String)n.f3.accept(this, argu), lnum, curproc);
         lnum++;
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         String reg1 = loadRegisterNo((String) n.f1.accept(this, argu),true);
         String val = (String) n.f2.accept(this, argu);
         String reg2 = loadRegisterNo((String) n.f3.accept(this, argu),true);
         String pr1 = ("HSTORE "+reg1);
         String pr2 = (" "+val+" "+reg2);
         System.out.println(pr1+pr2);
         return _ret;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);    
         n.f3.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         Map.TempStart((String)n.f1.accept(this, argu), lnum, curproc);
         Map.TempEnd((String) n.f2.accept(this, argu), lnum, curproc);
         n.f3.accept(this, argu);
         lnum++;
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         String zer = (String) n.f0.accept(this, argu);
         String tem1 = (String) n.f1.accept(this, argu);
         String ar = tem1;
         String reg1 = giveRegNo(ar);
         String reg2 = loadRegisterNo((String)n.f2.accept(this, argu),true);
         String val = (String) n.f3.accept(this, argu);

         if(reg1==null) useful2=false;
         else{ }
         if(useful2)
         {
            if(reg1.compareTo("stack")==0)
            {
               System.out.println("HLOAD v0 "+reg2 + " " + val);
               int stacklocation = SpillMop2.locateOnStack(tem1);
               if(stacklocation!=-1)
               {
                  String str = stacklocation +" v0";
                  System.out.println("ASTORE SPILLEDARG "+str);
               }
               else 
               {
                  System.out.println("ASTORE SPILLEDARG "+stackcur2+" v0");
                  StackEnt newt = new StackEnt();
                  String a = tem1;
                  newt.setSpillNo(stackcur2);
                  newt.setTemporaryNo(a);
                  SpillMop2.stackDeets.add(newt);
                  stackcur2++;
               }
            }
            else 
            {
               System.out.println("HLOAD "+reg1+" "+reg2 + " " + val);
            }
         }
         useful2=true;
         return _ret;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);    
         n.f3.accept(this, argu);
         return _ret;
      }
   }


   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         Map.TempStart((String) n.f1.accept(this, argu), lnum, curproc);
         n.f2.accept(this, argu);
         lnum++;
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         String temp = (String) n.f1.accept(this, argu);
         boolean flag = true;
         String reg = giveRegNo(temp);

         if(reg==null && flag) useful2=false;

         if(useful2)
         {
            String exp = (String) n.f2.accept(this, argu);

            if(reg.compareTo("stack")==0)
            {
               String mov = "MOVE v0 "+exp;
               System.out.println(mov);
               int stacklocation = SpillMop2.locateOnStack(temp);
               if(stacklocation!=-1)
               {
                  String str = stacklocation+" v0";
                  System.out.println("ASTORE SPILLEDARG "+str);
               }
               else
               {
                  System.out.println("ASTORE SPILLEDARG "+ stackcur2 + " v0");
                  StackEnt newt = new StackEnt();
                  newt.setSpillNo(stackcur2);
                  newt.setTemporaryNo(temp);
                  int newsc = stackcur2+1;
                  SpillMop2.stackDeets.add(newt);
                  stackcur2 = newsc;
               }
            }

            else 
            {
               System.out.println("MOVE "+reg+" "+exp);
            }
         }

         useful2=true;
         return _ret;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
         
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         Map.TempEnd((String)n.f1.accept(this, argu), lnum, curproc);
         lnum++;      
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         System.out.println("PRINT "+(String)n.f1.accept(this, argu));
         return _ret;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;     
         return (R) ((String)n.f0.accept(this, argu));
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);

         return _ret;
      }
   }

   

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         lnum++;
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         n.f3.accept(this, argu);
         lnum++;
         n.f4.accept(this, argu);
         lnum++;
         return _ret;
      }
      else if(passnumber==2)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         Analyse(curproc2);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         System.out.println("MOVE v0 "+(String)n.f3.accept(this, argu));    
         n.f4.accept(this, argu);
         return _ret;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);    
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;  
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         boolean tflag = true;
         arguments = tflag;
         n.f3.accept(this, argu);
         arguments = !tflag;
         Map.Procedures.get(curproc).calls.add(num_args);
         int z = 0;
         num_args=z;
         n.f4.accept(this, argu);
         return _ret;
      }
      else if(passnumber==2)
      { 
         n.f0.accept(this, argu);
         String lbl = (String) n.f1.accept(this, argu);
         n.f2.accept(this, argu);
         int bcarg = stackcur2;
         SpillMop2.beginCall(bcarg);
         arguments2=true;
         n.f3.accept(this, argu);
         boolean flag=true;
         arguments2=!flag;
         int z = 0;
         num_arguments2=z;
         n.f4.accept(this, argu);
         String pr = "CALL "+lbl;
         System.out.println(pr);
         int set = stackcur2;
         SpillMop2.endCall(set);
         return (R) "v0";
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);    
         n.f3.accept(this, argu);
         n.f4.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         return _ret;
      }
      else if(passnumber==2)
      {
         n.f0.accept(this, argu);
         return (R) (" HALLOCATE " +(String)n.f1.accept(this, argu));
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         Map.TempEnd((String) n.f1.accept(this, argu), lnum, curproc);
         n.f2.accept(this, argu);
         return _ret;
      }
      else if(passnumber==2)
      {
         return (R) ((String) n.f0.accept(this, argu)+" "+ loadRegisterNo((String)n.f1.accept(this, argu),true) +" "+((String) n.f2.accept(this, argu)));                     //make 1 statement and see if works
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
         n.f2.accept(this, argu);    
         
         return _ret;
      }
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      
      if(passnumber==1)
      {
         R _ret=null;
         n.f0.accept(this, argu);
         return _ret;
      }
      else if(passnumber==2)
      {
         return (R) ((String)n.f0.accept(this, argu));
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         return _ret;
      }
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      
      if(passnumber==1)
      {
         boolean f = true;
         label_start=!f;
         temporary=false;
         String t1 = (String) n.f0.accept(this, argu);
         label_start = f;
         if(temporary) Map.TempEnd(t1,lnum, curproc);
         temporary=false;
         return (R) t1;
      }
      else if(passnumber==2)
      {
         labelstart2=false;
         temporary2=false;
         String reg = (String) n.f0.accept(this, argu);
         if(temporary2) 
         {
            String tp = reg;
            reg = loadRegisterNo(tp,true);
         }
         temporary2=false;
         labelstart2=true;
         return (R) reg;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         return _ret;
      }

   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      
      if(passnumber==1)
      {
         n.f0.accept(this, argu);
         String tempn = (String) n.f1.accept(this, argu);
         temporary=true;
         if(arguments)
         {
            String str = "T"+tempn;
            Map.TempEnd(str,lnum,curproc);
            num_args++;
         }
         return (R) ("T"+tempn);
      }
      else if(passnumber==2)
      {
         temporary2=true;
         n.f0.accept(this, argu);
         String tnum = (String) n.f1.accept(this, argu);
         if(arguments2==true)
         {        
            String a = "T"+tnum;
            special2=true;
            String reg = loadRegisterNo(a,true);
            special2=false;
            if(num_arguments2<4)
            {
               String str1 = "MOVE a";
               System.out.println(str1+num_arguments2+" "+reg);
            }
            else 
            {
               String str2 = "PASSARG ";
               System.out.println(str2+(num_arguments2-3)+" "+reg);
            }
            num_arguments2++;
         }
         String ret = "T"+tnum;
         return (R) (ret);
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         n.f1.accept(this, argu);
      
         return _ret;
      }
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
         
      if(passnumber==1)
      {       
         return (R) ((String) n.f0.accept(this, argu));
      }
      else if(passnumber==2)
      {      
         return (R) ((String)n.f0.accept(this, argu));
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         
         return _ret;
      }
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      
      if(passnumber==1)
      { 
         String str = (String) n.f0.accept(this, argu);
         if(label_start) 
         {
            Map.LabelStart(str, lnum, curproc);
            lnum++;
         }
         return (R) str;
      }
      else if(passnumber==2)
      {
         String id = (String) n.f0.accept(this, argu);
         if(labelstart2) System.out.println(id);
         return (R) id;
      }
      else 
      {
         R _ret=null;
         n.f0.accept(this, argu);
         return _ret;
      }
   }

}
